<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenMesh: OpenMesh::SmartRangeT&lt; RangeT, HandleT &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="logo_align.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="rwth_vci_rgb.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenMesh
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a02449.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="a02446.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">OpenMesh::SmartRangeT&lt; RangeT, HandleT &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Base class for all smart range types.  
 <a href="a02449.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00398_source.html">OpenMesh/Core/Mesh/SmartRange.hh</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6d517ba9c7660804b7726159be648c70"><td class="memItemLeft" align="right" valign="top"><a id="a6d517ba9c7660804b7726159be648c70"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Handle</b> = HandleT</td></tr>
<tr class="separator:a6d517ba9c7660804b7726159be648c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84932795e95ab61153177fb0f4acaee9"><td class="memItemLeft" align="right" valign="top"><a id="a84932795e95ab61153177fb0f4acaee9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SmartRange</b> = <a class="el" href="a02449.html">SmartRangeT</a>&lt; RangeT, HandleT &gt;</td></tr>
<tr class="separator:a84932795e95ab61153177fb0f4acaee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d89282261d8482f97a5cfa6da80268"><td class="memItemLeft" align="right" valign="top"><a id="aa7d89282261d8482f97a5cfa6da80268"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Range</b> = RangeT</td></tr>
<tr class="separator:aa7d89282261d8482f97a5cfa6da80268"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a13c21382cae3ce215ca156b6a455ab37"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a13c21382cae3ce215ca156b6a455ab37"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a02449.html#a13c21382cae3ce215ca156b6a455ab37">sum</a> (Functor &amp;&amp;f) -&gt; typename std::decay&lt; decltype(f(std::declval&lt; HandleT &gt;()))&gt;::type</td></tr>
<tr class="memdesc:a13c21382cae3ce215ca156b6a455ab37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of elements.  <a href="#a13c21382cae3ce215ca156b6a455ab37">More...</a><br /></td></tr>
<tr class="separator:a13c21382cae3ce215ca156b6a455ab37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2ba886e721dea119dcf97226e5430a"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a2c2ba886e721dea119dcf97226e5430a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a02449.html#a2c2ba886e721dea119dcf97226e5430a">avg</a> (Functor &amp;&amp;f) -&gt; typename std::decay&lt; decltype(f(std::declval&lt; HandleT &gt;()))&gt;::type</td></tr>
<tr class="memdesc:a2c2ba886e721dea119dcf97226e5430a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of elements.  <a href="#a2c2ba886e721dea119dcf97226e5430a">More...</a><br /></td></tr>
<tr class="separator:a2c2ba886e721dea119dcf97226e5430a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309f1e6f1f697950f43a1c767ebd84db"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a309f1e6f1f697950f43a1c767ebd84db"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a02449.html#a309f1e6f1f697950f43a1c767ebd84db">any_of</a> (Functor &amp;&amp;f) -&gt; bool</td></tr>
<tr class="memdesc:a309f1e6f1f697950f43a1c767ebd84db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if any element fulfils condition.  <a href="#a309f1e6f1f697950f43a1c767ebd84db">More...</a><br /></td></tr>
<tr class="separator:a309f1e6f1f697950f43a1c767ebd84db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a9d3a656c33fcf584bcfccda4359cc4"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a4a9d3a656c33fcf584bcfccda4359cc4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a02449.html#a4a9d3a656c33fcf584bcfccda4359cc4">all_of</a> (Functor &amp;&amp;f) -&gt; bool</td></tr>
<tr class="memdesc:a4a9d3a656c33fcf584bcfccda4359cc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if all elements fulfil condition.  <a href="#a4a9d3a656c33fcf584bcfccda4359cc4">More...</a><br /></td></tr>
<tr class="separator:a4a9d3a656c33fcf584bcfccda4359cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c4593922358a4b168ed8c05f15afc2"><td class="memTemplParams" colspan="2">template&lt;int n, typename Functor  = Identity&gt; </td></tr>
<tr class="memitem:a16c4593922358a4b168ed8c05f15afc2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a02449.html#a16c4593922358a4b168ed8c05f15afc2">to_array</a> (Functor &amp;&amp;f={}) -&gt; std::array&lt; typename std::decay&lt; decltype(f(std::declval&lt; HandleT &gt;()))&gt;::type, n &gt;</td></tr>
<tr class="memdesc:a16c4593922358a4b168ed8c05f15afc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert range to array.  <a href="#a16c4593922358a4b168ed8c05f15afc2">More...</a><br /></td></tr>
<tr class="separator:a16c4593922358a4b168ed8c05f15afc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5379ce715caba78466cc8a2f2faa4f"><td class="memTemplParams" colspan="2">template&lt;typename Functor  = Identity&gt; </td></tr>
<tr class="memitem:a8f5379ce715caba78466cc8a2f2faa4f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a02449.html#a8f5379ce715caba78466cc8a2f2faa4f">to_vector</a> (Functor &amp;&amp;f={}) -&gt; std::vector&lt; typename std::decay&lt; decltype(f(std::declval&lt; HandleT &gt;()))&gt;::type &gt;</td></tr>
<tr class="memdesc:a8f5379ce715caba78466cc8a2f2faa4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert range to vector.  <a href="#a8f5379ce715caba78466cc8a2f2faa4f">More...</a><br /></td></tr>
<tr class="separator:a8f5379ce715caba78466cc8a2f2faa4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eae509ef5701b4f8186a8ba54f8e71a"><td class="memTemplParams" colspan="2">template&lt;typename Functor  = Identity&gt; </td></tr>
<tr class="memitem:a0eae509ef5701b4f8186a8ba54f8e71a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a02449.html#a0eae509ef5701b4f8186a8ba54f8e71a">to_set</a> (Functor &amp;&amp;f={}) -&gt; std::set&lt; typename std::decay&lt; decltype(f(std::declval&lt; HandleT &gt;()))&gt;::type &gt;</td></tr>
<tr class="memdesc:a0eae509ef5701b4f8186a8ba54f8e71a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert range to set.  <a href="#a0eae509ef5701b4f8186a8ba54f8e71a">More...</a><br /></td></tr>
<tr class="separator:a0eae509ef5701b4f8186a8ba54f8e71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388aab8e4c2f8940a360d52014c009e5"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a388aab8e4c2f8940a360d52014c009e5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a02449.html#a388aab8e4c2f8940a360d52014c009e5">first</a> (Functor &amp;&amp;f={}) -&gt; HandleT</td></tr>
<tr class="memdesc:a388aab8e4c2f8940a360d52014c009e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first element that fulfills a condition.  <a href="#a388aab8e4c2f8940a360d52014c009e5">More...</a><br /></td></tr>
<tr class="separator:a388aab8e4c2f8940a360d52014c009e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f050f7d137ab90950b5d668adcf57b9"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a2f050f7d137ab90950b5d668adcf57b9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a02449.html#a2f050f7d137ab90950b5d668adcf57b9">min</a> (Functor &amp;&amp;f) -&gt; typename std::decay&lt; decltype(f(std::declval&lt; HandleT &gt;()))&gt;::type</td></tr>
<tr class="memdesc:a2f050f7d137ab90950b5d668adcf57b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute minimum.  <a href="#a2f050f7d137ab90950b5d668adcf57b9">More...</a><br /></td></tr>
<tr class="separator:a2f050f7d137ab90950b5d668adcf57b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6235d6a30db15bf11c144aa6899c5aa"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:ac6235d6a30db15bf11c144aa6899c5aa"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a02449.html#ac6235d6a30db15bf11c144aa6899c5aa">argmin</a> (Functor &amp;&amp;f) -&gt; HandleT</td></tr>
<tr class="memdesc:ac6235d6a30db15bf11c144aa6899c5aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute minimal element.  <a href="#ac6235d6a30db15bf11c144aa6899c5aa">More...</a><br /></td></tr>
<tr class="separator:ac6235d6a30db15bf11c144aa6899c5aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7759756216e3c7390145b59a3b89f30"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:ac7759756216e3c7390145b59a3b89f30"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a02449.html#ac7759756216e3c7390145b59a3b89f30">max</a> (Functor &amp;&amp;f) -&gt; typename std::decay&lt; decltype(f(std::declval&lt; HandleT &gt;()))&gt;::type</td></tr>
<tr class="memdesc:ac7759756216e3c7390145b59a3b89f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute maximum.  <a href="#ac7759756216e3c7390145b59a3b89f30">More...</a><br /></td></tr>
<tr class="separator:ac7759756216e3c7390145b59a3b89f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ffe4f602539cfdb7c112761a9a0380f"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a1ffe4f602539cfdb7c112761a9a0380f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a02449.html#a1ffe4f602539cfdb7c112761a9a0380f">argmax</a> (Functor &amp;&amp;f) -&gt; HandleT</td></tr>
<tr class="memdesc:a1ffe4f602539cfdb7c112761a9a0380f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute maximal element.  <a href="#a1ffe4f602539cfdb7c112761a9a0380f">More...</a><br /></td></tr>
<tr class="separator:a1ffe4f602539cfdb7c112761a9a0380f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff87b59192f68142138506a9bbb1a2c"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a2ff87b59192f68142138506a9bbb1a2c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a02449.html#a2ff87b59192f68142138506a9bbb1a2c">minmax</a> (Functor &amp;&amp;f) -&gt; std::pair&lt; typename std::decay&lt; decltype(f(std::declval&lt; HandleT &gt;()))&gt;::type, typename std::decay&lt; decltype(f(std::declval&lt; HandleT &gt;()))&gt;::type &gt;</td></tr>
<tr class="memdesc:a2ff87b59192f68142138506a9bbb1a2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes minimum and maximum.  <a href="#a2ff87b59192f68142138506a9bbb1a2c">More...</a><br /></td></tr>
<tr class="separator:a2ff87b59192f68142138506a9bbb1a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4acf811b1e582629520ca5b8fe0a56"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:aca4acf811b1e582629520ca5b8fe0a56"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a02449.html#aca4acf811b1e582629520ca5b8fe0a56">count_if</a> (Functor &amp;&amp;f) -&gt; int</td></tr>
<tr class="memdesc:aca4acf811b1e582629520ca5b8fe0a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute number of elements that satisfy a given predicate.  <a href="#aca4acf811b1e582629520ca5b8fe0a56">More...</a><br /></td></tr>
<tr class="separator:aca4acf811b1e582629520ca5b8fe0a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a9720472809f9a1492a69cc96456427"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a0a9720472809f9a1492a69cc96456427"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a02449.html#a0a9720472809f9a1492a69cc96456427">for_each</a> (Functor &amp;&amp;f) -&gt; void</td></tr>
<tr class="memdesc:a0a9720472809f9a1492a69cc96456427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a functor to each element.  <a href="#a0a9720472809f9a1492a69cc96456427">More...</a><br /></td></tr>
<tr class="separator:a0a9720472809f9a1492a69cc96456427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81058b0a7ab06693d05231d552584e2b"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a81058b0a7ab06693d05231d552584e2b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a02449.html#a81058b0a7ab06693d05231d552584e2b">filtered</a> (Functor &amp;&amp;f) -&gt; <a class="el" href="a02445.html">FilteredSmartRangeT</a>&lt; <a class="el" href="a02449.html">SmartRange</a>, Handle, typename std::decay&lt; Functor &gt;::type &gt;</td></tr>
<tr class="memdesc:a81058b0a7ab06693d05231d552584e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only iterate over a subset of elements.  <a href="#a81058b0a7ab06693d05231d552584e2b">More...</a><br /></td></tr>
<tr class="separator:a81058b0a7ab06693d05231d552584e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename RangeT, typename HandleT&gt;<br />
struct OpenMesh::SmartRangeT&lt; RangeT, HandleT &gt;</h3>

<p>Base class for all smart range types. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a4a9d3a656c33fcf584bcfccda4359cc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a9d3a656c33fcf584bcfccda4359cc4">&#9670;&nbsp;</a></span>all_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT, typename HandleT&gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="a02449.html">OpenMesh::SmartRangeT</a>&lt; RangeT, HandleT &gt;::all_of </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> -&gt; bool
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if all elements fulfil condition. </p>
<p>Checks if functor <code>f</code> returns true for all of the elements in the range. Returns true if that is the case, false otherwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Functor that is evaluated for all elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a309f1e6f1f697950f43a1c767ebd84db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a309f1e6f1f697950f43a1c767ebd84db">&#9670;&nbsp;</a></span>any_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT, typename HandleT&gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="a02449.html">OpenMesh::SmartRangeT</a>&lt; RangeT, HandleT &gt;::any_of </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> -&gt; bool
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if any element fulfils condition. </p>
<p>Checks if functor <code>f</code> returns true for any of the elements in the range. Returns true if that is the case, false otherwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Functor that is evaluated for all elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ffe4f602539cfdb7c112761a9a0380f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ffe4f602539cfdb7c112761a9a0380f">&#9670;&nbsp;</a></span>argmax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT, typename HandleT&gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="a02449.html">OpenMesh::SmartRangeT</a>&lt; RangeT, HandleT &gt;::argmax </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> -&gt; HandleT
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute maximal element. </p>
<p>Computes the element that maximizes <code>f</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Functor that is applied to all elements before comparing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6235d6a30db15bf11c144aa6899c5aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6235d6a30db15bf11c144aa6899c5aa">&#9670;&nbsp;</a></span>argmin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT, typename HandleT&gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="a02449.html">OpenMesh::SmartRangeT</a>&lt; RangeT, HandleT &gt;::argmin </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> -&gt; HandleT
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute minimal element. </p>
<p>Computes the element that minimizes <code>f</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Functor that is applied to all elements before comparing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c2ba886e721dea119dcf97226e5430a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c2ba886e721dea119dcf97226e5430a">&#9670;&nbsp;</a></span>avg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT, typename HandleT&gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="a02449.html">OpenMesh::SmartRangeT</a>&lt; RangeT, HandleT &gt;::avg </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> -&gt; typename std::decay&lt;decltype (f(std::declval&lt;HandleT&gt;()))&gt;::type
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the average of elements. </p>
<p>Computes the average of all elements in the range after applying the functor <code>f</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Functor that is applied to all elements before computing the average. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca4acf811b1e582629520ca5b8fe0a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4acf811b1e582629520ca5b8fe0a56">&#9670;&nbsp;</a></span>count_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT, typename HandleT&gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="a02449.html">OpenMesh::SmartRangeT</a>&lt; RangeT, HandleT &gt;::count_if </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> -&gt; int
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute number of elements that satisfy a given predicate. </p>
<p>Computes the numer of elements which satisfy functor <code>f</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Predicate that elements have to satisfy in order to be counted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81058b0a7ab06693d05231d552584e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81058b0a7ab06693d05231d552584e2b">&#9670;&nbsp;</a></span>filtered()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT, typename HandleT&gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="a02449.html">OpenMesh::SmartRangeT</a>&lt; RangeT, HandleT &gt;::filtered </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> -&gt; <a class="el" href="a02445.html">FilteredSmartRangeT</a>&lt;<a class="el" href="a02449.html">SmartRange</a>, Handle, typename std::decay&lt;Functor&gt;::type&gt;
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Only iterate over a subset of elements. </p>
<p>Returns a smart range which skips all elements that do not satisfy functor <code>f</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Functor that needs to be evaluated to true if the element should not be skipped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a388aab8e4c2f8940a360d52014c009e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a388aab8e4c2f8940a360d52014c009e5">&#9670;&nbsp;</a></span>first()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT, typename HandleT&gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="a02449.html">OpenMesh::SmartRangeT</a>&lt; RangeT, HandleT &gt;::first </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>{}</code></td><td>)</td>
          <td> -&gt; HandleT
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the first element that fulfills a condition. </p>
<p>Finds the first element of the range for which the functor <code>f</code> evaluates to true. Returns an invalid handle if none evaluates to true</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Functor that is applied to all elements before putting them into the set. If no functor is provided the set will contain the handles. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a9720472809f9a1492a69cc96456427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a9720472809f9a1492a69cc96456427">&#9670;&nbsp;</a></span>for_each()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT, typename HandleT&gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="a02449.html">OpenMesh::SmartRangeT</a>&lt; RangeT, HandleT &gt;::for_each </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> -&gt; void
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a functor to each element. </p>
<p>Calls functor <code>f</code> with each element as parameter</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Functor that is called for each element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7759756216e3c7390145b59a3b89f30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7759756216e3c7390145b59a3b89f30">&#9670;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT, typename HandleT&gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="a02449.html">OpenMesh::SmartRangeT</a>&lt; RangeT, HandleT &gt;::max </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> -&gt; typename std::decay&lt;decltype (f(std::declval&lt;HandleT&gt;()))&gt;::type
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute maximum. </p>
<p>Computes the maximum of all objects returned by functor <code>f</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Functor that is applied to all elements before computing maximum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f050f7d137ab90950b5d668adcf57b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f050f7d137ab90950b5d668adcf57b9">&#9670;&nbsp;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT, typename HandleT&gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="a02449.html">OpenMesh::SmartRangeT</a>&lt; RangeT, HandleT &gt;::min </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> -&gt; typename std::decay&lt;decltype (f(std::declval&lt;HandleT&gt;()))&gt;::type
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute minimum. </p>
<p>Computes the minimum of all objects returned by functor <code>f</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Functor that is applied to all elements before computing minimum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ff87b59192f68142138506a9bbb1a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ff87b59192f68142138506a9bbb1a2c">&#9670;&nbsp;</a></span>minmax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT, typename HandleT&gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="a02449.html">OpenMesh::SmartRangeT</a>&lt; RangeT, HandleT &gt;::minmax </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> -&gt; std::pair&lt;typename std::decay&lt;decltype (f(std::declval&lt;HandleT&gt;()))&gt;::type,
                                        typename std::decay&lt;decltype (f(std::declval&lt;HandleT&gt;()))&gt;::type&gt;
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes minimum and maximum. </p>
<p>Computes the minimum and maximum of all objects returned by functor <code>f</code>. Result is returned as std::pair containing minimum as first and maximum as second element.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Functor that is applied to all elements before computing maximum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13c21382cae3ce215ca156b6a455ab37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c21382cae3ce215ca156b6a455ab37">&#9670;&nbsp;</a></span>sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT, typename HandleT&gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="a02449.html">OpenMesh::SmartRangeT</a>&lt; RangeT, HandleT &gt;::sum </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> -&gt; typename std::decay&lt;decltype (f(std::declval&lt;HandleT&gt;()))&gt;::type
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sum of elements. </p>
<p>Computes the sum of all elements in the range after applying the functor <code>f</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Functor that is applied to all elements before computing the sum </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16c4593922358a4b168ed8c05f15afc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c4593922358a4b168ed8c05f15afc2">&#9670;&nbsp;</a></span>to_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT, typename HandleT&gt; </div>
<div class="memtemplate">
template&lt;int n, typename Functor  = Identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="a02449.html">OpenMesh::SmartRangeT</a>&lt; RangeT, HandleT &gt;::to_array </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>{}</code></td><td>)</td>
          <td> -&gt; std::array&lt;typename std::decay&lt;decltype (f(std::declval&lt;HandleT&gt;()))&gt;::type, n&gt;
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert range to array. </p>
<p>Converts the range of elements into an array of objects returned by functor <code>f</code>. The size of the array needs to be provided by the user. If the size is larger than the number of elements in the range, the remaining entries of the array will be uninitialized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Functor that is applied to all elements before putting them into the array. If no functor is provided the array will contain the handles. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0eae509ef5701b4f8186a8ba54f8e71a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eae509ef5701b4f8186a8ba54f8e71a">&#9670;&nbsp;</a></span>to_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT, typename HandleT&gt; </div>
<div class="memtemplate">
template&lt;typename Functor  = Identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="a02449.html">OpenMesh::SmartRangeT</a>&lt; RangeT, HandleT &gt;::to_set </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>{}</code></td><td>)</td>
          <td> -&gt; std::set&lt;typename std::decay&lt;decltype (f(std::declval&lt;HandleT&gt;()))&gt;::type&gt;
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert range to set. </p>
<p>Converts the range of elements into a set of objects returned by functor <code>f</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Functor that is applied to all elements before putting them into the set. If no functor is provided the set will contain the handles. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f5379ce715caba78466cc8a2f2faa4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f5379ce715caba78466cc8a2f2faa4f">&#9670;&nbsp;</a></span>to_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT, typename HandleT&gt; </div>
<div class="memtemplate">
template&lt;typename Functor  = Identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="a02449.html">OpenMesh::SmartRangeT</a>&lt; RangeT, HandleT &gt;::to_vector </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>{}</code></td><td>)</td>
          <td> -&gt; std::vector&lt;typename std::decay&lt;decltype (f(std::declval&lt;HandleT&gt;()))&gt;::type&gt;
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert range to vector. </p>
<p>Converts the range of elements into a vector of objects returned by functor <code>f</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Functor that is applied to all elements before putting them into the vector. If no functor is provided the vector will contain the handles. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>OpenMesh/Core/Mesh/<a class="el" href="a00398_source.html">SmartRange.hh</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr>
<address>
<small>
<a href="http://www.rwth-graphics.de" style="text-decoration:none;">
</a>
Project <b>OpenMesh</b>, 
&copy;&nbsp; Computer Graphics Group, RWTH Aachen.
Documentation generated using 
<a class="el" href="http://www.doxygen.org/index.html">
<b>doxygen</b>
</a>.
</small>
</address>
</body>
</html>
