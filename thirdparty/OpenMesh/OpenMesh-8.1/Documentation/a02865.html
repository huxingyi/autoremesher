<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenMesh: OpenMesh::Subdivider::Adaptive::CompositeT&lt; M &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="logo_align.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="rwth_vci_rgb.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenMesh
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a02865.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="a02862.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">OpenMesh::Subdivider::Adaptive::CompositeT&lt; M &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="a01241.html" title="Software related to adaptive subdivision of meshes. ">Adaptive</a> Composite Subdivision framework.  
 <a href="a02865.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a04491_source.html">OpenMesh/Tools/Subdivider/Adaptive/Composite/CompositeT.hh</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6a7324f11505d0140f4ce947c3e7872a"><td class="memItemLeft" align="right" valign="top"><a id="a6a7324f11505d0140f4ce947c3e7872a"></a>
typedef <a class="el" href="a02861.html">RuleInterfaceT</a>&lt; M &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Rule</b></td></tr>
<tr class="separator:a6a7324f11505d0140f4ce947c3e7872a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75c59efa30d205c67d551d1cc7e5339"><td class="memItemLeft" align="right" valign="top"><a id="aa75c59efa30d205c67d551d1cc7e5339"></a>
typedef M&#160;</td><td class="memItemRight" valign="bottom"><b>Mesh</b></td></tr>
<tr class="separator:aa75c59efa30d205c67d551d1cc7e5339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27da6988470ed03567f5d4f39f850c97"><td class="memItemLeft" align="right" valign="top"><a id="a27da6988470ed03567f5d4f39f850c97"></a>
typedef std::vector&lt; <a class="el" href="a02861.html">Rule</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RuleSequence</b></td></tr>
<tr class="separator:a27da6988470ed03567f5d4f39f850c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94af1e7b58406bbd5cdd2df34389ac5e"><td class="memItemLeft" align="right" valign="top"><a id="a94af1e7b58406bbd5cdd2df34389ac5e"></a>
typedef M::VertexHandle&#160;</td><td class="memItemRight" valign="bottom"><b>VH</b></td></tr>
<tr class="separator:a94af1e7b58406bbd5cdd2df34389ac5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6706919876617cbceb3fe854a3fd2769"><td class="memItemLeft" align="right" valign="top"><a id="a6706919876617cbceb3fe854a3fd2769"></a>
typedef M::FaceHandle&#160;</td><td class="memItemRight" valign="bottom"><b>FH</b></td></tr>
<tr class="separator:a6706919876617cbceb3fe854a3fd2769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f680a429898a23ad7874257ce816c0"><td class="memItemLeft" align="right" valign="top"><a id="a77f680a429898a23ad7874257ce816c0"></a>
typedef M::EdgeHandle&#160;</td><td class="memItemRight" valign="bottom"><b>EH</b></td></tr>
<tr class="separator:a77f680a429898a23ad7874257ce816c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6d1e782257d9c352076571c6e8f493"><td class="memItemLeft" align="right" valign="top"><a id="acd6d1e782257d9c352076571c6e8f493"></a>
typedef M::HalfedgeHandle&#160;</td><td class="memItemRight" valign="bottom"><b>HH</b></td></tr>
<tr class="separator:acd6d1e782257d9c352076571c6e8f493"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a14acda841f3f50918ce31e07b56ba507"><td class="memItemLeft" align="right" valign="top"><a id="a14acda841f3f50918ce31e07b56ba507"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02865.html#a14acda841f3f50918ce31e07b56ba507">CompositeT</a> (Mesh &amp;_mesh)</td></tr>
<tr class="memdesc:a14acda841f3f50918ce31e07b56ba507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a14acda841f3f50918ce31e07b56ba507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80960eb4a617e8bd46fdebdf842c4f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02865.html#ad80960eb4a617e8bd46fdebdf842c4f1">cleanup</a> (void)</td></tr>
<tr class="memdesc:ad80960eb4a617e8bd46fdebdf842c4f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset <code>self</code> to state after the default constructor except of the mesh.  <a href="#ad80960eb4a617e8bd46fdebdf842c4f1">More...</a><br /></td></tr>
<tr class="separator:ad80960eb4a617e8bd46fdebdf842c4f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18fd11270e399c7ede5f9a45373cf193"><td class="memItemLeft" align="right" valign="top"><a id="a18fd11270e399c7ede5f9a45373cf193"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02865.html#a18fd11270e399c7ede5f9a45373cf193">initialize</a> (void)</td></tr>
<tr class="memdesc:a18fd11270e399c7ede5f9a45373cf193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize faces, edges, vertices, and rules. <br /></td></tr>
<tr class="separator:a18fd11270e399c7ede5f9a45373cf193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51784d44a9134dd09718617349cce09"><td class="memItemLeft" align="right" valign="top"><a id="ae51784d44a9134dd09718617349cce09"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02865.html#ae51784d44a9134dd09718617349cce09">refine</a> (typename M::FaceHandle &amp;_fh)</td></tr>
<tr class="memdesc:ae51784d44a9134dd09718617349cce09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refine one face. <br /></td></tr>
<tr class="separator:ae51784d44a9134dd09718617349cce09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244944f4dfef7629d18a96da2e488a0d"><td class="memItemLeft" align="right" valign="top"><a id="a244944f4dfef7629d18a96da2e488a0d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02865.html#a244944f4dfef7629d18a96da2e488a0d">refine</a> (typename M::VertexHandle &amp;_vh)</td></tr>
<tr class="memdesc:a244944f4dfef7629d18a96da2e488a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raise one vertex to next final level. <br /></td></tr>
<tr class="separator:a244944f4dfef7629d18a96da2e488a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33f9634758aeb49fa9dc0efc2adf6b9"><td class="memItemLeft" align="right" valign="top"><a id="ae33f9634758aeb49fa9dc0efc2adf6b9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02865.html#ae33f9634758aeb49fa9dc0efc2adf6b9">subdiv_type</a> ()</td></tr>
<tr class="memdesc:ae33f9634758aeb49fa9dc0efc2adf6b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return subdivision split type (3 for 1-to-3 split, 4 for 1-to-4 split). <br /></td></tr>
<tr class="separator:ae33f9634758aeb49fa9dc0efc2adf6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f860de1f18dca6af91aa8666e368204"><td class="memItemLeft" align="right" valign="top"><a id="a7f860de1f18dca6af91aa8666e368204"></a>
const <a class="el" href="a02861.html">Rule</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>subdiv_rule</b> () const</td></tr>
<tr class="separator:a7f860de1f18dca6af91aa8666e368204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Managing composite rules</div></td></tr>
<tr class="memitem:a9822926fab6924d5c9d5ada7a2db366e"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a9822926fab6924d5c9d5ada7a2db366e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02857.html">RuleHandleT</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a02865.html#a9822926fab6924d5c9d5ada7a2db366e">add</a> ()</td></tr>
<tr class="memdesc:a9822926fab6924d5c9d5ada7a2db366e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add new rule to rule sequence by passing the type of the wanted rule as template argument to the method.  <a href="#a9822926fab6924d5c9d5ada7a2db366e">More...</a><br /></td></tr>
<tr class="separator:a9822926fab6924d5c9d5ada7a2db366e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748163a4a7c7f45f7714ae5ff724d014"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a748163a4a7c7f45f7714ae5ff724d014"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02857.html">RuleHandleT</a>&lt; R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a02865.html#a748163a4a7c7f45f7714ae5ff724d014">add</a> (<a class="el" href="a02857.html">RuleHandleT</a>&lt; R &gt; &amp;_rh)</td></tr>
<tr class="memdesc:a748163a4a7c7f45f7714ae5ff724d014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add new rule to rule sequence by passing an appropriate handle to the method.  <a href="#a748163a4a7c7f45f7714ae5ff724d014">More...</a><br /></td></tr>
<tr class="separator:a748163a4a7c7f45f7714ae5ff724d014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ff9d4f4a55f612ee10dd1c5d0aa60d"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a99ff9d4f4a55f612ee10dd1c5d0aa60d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02857.html">RuleHandleT</a>&lt; R &gt;::<a class="el" href="a02861.html">Rule</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a02865.html#a99ff9d4f4a55f612ee10dd1c5d0aa60d">rule</a> (const <a class="el" href="a02857.html">RuleHandleT</a>&lt; R &gt; &amp;_rh)</td></tr>
<tr class="memdesc:a99ff9d4f4a55f612ee10dd1c5d0aa60d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get rule in the rule sequence by a handle.  <a href="#a99ff9d4f4a55f612ee10dd1c5d0aa60d">More...</a><br /></td></tr>
<tr class="separator:a99ff9d4f4a55f612ee10dd1c5d0aa60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df1c3098721d47a64c64f9bbafe5639"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a02861.html">RuleInterfaceT</a>&lt; M &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02865.html#a8df1c3098721d47a64c64f9bbafe5639">rule</a> (size_t _idx)</td></tr>
<tr class="memdesc:a8df1c3098721d47a64c64f9bbafe5639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get rule (interface) by index.  <a href="#a8df1c3098721d47a64c64f9bbafe5639">More...</a><br /></td></tr>
<tr class="separator:a8df1c3098721d47a64c64f9bbafe5639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd94e9a9a3b6c0c973904bcd3d19fd0"><td class="memItemLeft" align="right" valign="top"><a id="a1fd94e9a9a3b6c0c973904bcd3d19fd0"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02865.html#a1fd94e9a9a3b6c0c973904bcd3d19fd0">n_rules</a> () const</td></tr>
<tr class="memdesc:a1fd94e9a9a3b6c0c973904bcd3d19fd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of rules in the rule sequence. <br /></td></tr>
<tr class="separator:a1fd94e9a9a3b6c0c973904bcd3d19fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ef8fec36da611f409984d89540e7f3"><td class="memItemLeft" align="right" valign="top"><a id="a13ef8fec36da611f409984d89540e7f3"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02865.html#a13ef8fec36da611f409984d89540e7f3">rules_as_string</a> (const std::string &amp;_sep=&quot; * &quot;) const</td></tr>
<tr class="memdesc:a13ef8fec36da611f409984d89540e7f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sequence as string. <br /></td></tr>
<tr class="separator:a13ef8fec36da611f409984d89540e7f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:abf8a0cecb46f7acf03310359cd01cf05"><td class="memItemLeft" align="right" valign="top"><a id="abf8a0cecb46f7acf03310359cd01cf05"></a>
const RuleSequence &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02865.html#abf8a0cecb46f7acf03310359cd01cf05">rules</a> () const</td></tr>
<tr class="memdesc:abf8a0cecb46f7acf03310359cd01cf05"><td class="mdescLeft">&#160;</td><td class="mdescRight">The rule sequence. <br /></td></tr>
<tr class="separator:abf8a0cecb46f7acf03310359cd01cf05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d46d4ea36ae9929c51d6ffb4179b99"><td class="memItemLeft" align="right" valign="top"><a id="a64d46d4ea36ae9929c51d6ffb4179b99"></a>
<a class="el" href="a01241.html#af706613543b0da1b097580a9dc30fc6e">state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>generation</b> (<a class="el" href="a01241.html#af706613543b0da1b097580a9dc30fc6e">state_t</a> _s) const</td></tr>
<tr class="separator:a64d46d4ea36ae9929c51d6ffb4179b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17463bc4b4ae0802830ba4b143fa320d"><td class="memItemLeft" align="right" valign="top"><a id="a17463bc4b4ae0802830ba4b143fa320d"></a>
<a class="el" href="a01241.html#af706613543b0da1b097580a9dc30fc6e">state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>generation</b> (VH _vh) const</td></tr>
<tr class="separator:a17463bc4b4ae0802830ba4b143fa320d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8528e92c3036664c9adff0963dc6dd7"><td class="memItemLeft" align="right" valign="top"><a id="ab8528e92c3036664c9adff0963dc6dd7"></a>
<a class="el" href="a01241.html#af706613543b0da1b097580a9dc30fc6e">state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>generation</b> (EH _eh) const</td></tr>
<tr class="separator:ab8528e92c3036664c9adff0963dc6dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b9fd0d0fe8cf3b735c35f12648d09f5"><td class="memItemLeft" align="right" valign="top"><a id="a4b9fd0d0fe8cf3b735c35f12648d09f5"></a>
<a class="el" href="a01241.html#af706613543b0da1b097580a9dc30fc6e">state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>generation</b> (FH _fh) const</td></tr>
<tr class="separator:a4b9fd0d0fe8cf3b735c35f12648d09f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename M&gt;<br />
class OpenMesh::Subdivider::Adaptive::CompositeT&lt; M &gt;</h3>

<p><a class="el" href="a01241.html" title="Software related to adaptive subdivision of meshes. ">Adaptive</a> Composite Subdivision framework. </p>
<p>The adaptive composite subdivision framework is based on the work done by P. Oswald and P. Schroeder. This framework elevates the uniform case of the composite scheme to the adaptive setting.</p>
<p>For details on the composite scheme refer to</p><ul>
<li><a href="http://cm.bell-labs.com/who/poswald/sqrt3.pdf">P. Oswald, P. Schroeder "Composite primal/dual sqrt(3)-subdivision schemes", CAGD 20, 3, 2003, 135&ndash;164</a></li>
</ul>
<p>For details on the transition from uniform to adaptive composite subdivision please refer to</p><ul>
<li><a href="http://www.eg.org/EG/DL/PE/OPENSG03/04sovakar.pdf">A. von Studnitz, A. Sovakar, L. Kobbelt "API Design for Adaptive Subdivision
Schemes" OpenSG Symposium 2003</a></li>
</ul>
<p>In the composite scheme a subdivision operator is created by combining smaller "atomic" rules. Depending on the selection and ordering of the operator many known subdivision schemes can be created.</p>
<p>Every rule inherits from <a class="el" href="a02861.html" title="Base class for adaptive composite subdivision rules. ">RuleInterfaceT</a> and is represented out of the subdivider object by a <a class="el" href="a02857.html" title="Handle template for adaptive composite subdividion rules. ">RuleHandleT</a> (as usual within OpenMesh). You can add rules using the <a class="el" href="a02865.html#a9822926fab6924d5c9d5ada7a2db366e" title="Add new rule to rule sequence by passing the type of the wanted rule as template argument to the meth...">CompositeT::add()</a> functions. The correct order of adding the rules is very important, and furthermore not all rules get along with each other very well. (Please read the given literature, especially the paper by Oswald and Schrï¿½der.)</p>
<p>To use a composite subdivider first define a rule sequence describing the order of execution of the rules. In the order the rules habe been added they will be executed. E.g. the rules given in operator notation have to added from right to left.</p>
<p>After the rule sequence has been defined the subdivider has to be intialized using <a class="el" href="a02865.html#a18fd11270e399c7ede5f9a45373cf193" title="Initialize faces, edges, vertices, and rules. ">CompositeT::initialize()</a>. If everything went well, use <a class="el" href="a02865.html#ae51784d44a9134dd09718617349cce09" title="Refine one face. ">CompositeT::refine()</a> to subdivide locally a face or vertex.</p>
<dl class="section note"><dt>Note</dt><dd>Not all (topological) operators have been implemented! </dd>
<dd>
Only triangle meshes are supported. </dd>
<dd>
The rule sequence must begin with a topological operator.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a02861.html" title="Base class for adaptive composite subdivision rules. ">RuleInterfaceT</a>, <a class="el" href="a02857.html" title="Handle template for adaptive composite subdividion rules. ">RuleHandleT</a> </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a9822926fab6924d5c9d5ada7a2db366e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9822926fab6924d5c9d5ada7a2db366e">&#9670;&nbsp;</a></span>add() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<div class="memtemplate">
template&lt;typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02857.html">RuleHandleT</a>&lt;R&gt; <a class="el" href="a02865.html">OpenMesh::Subdivider::Adaptive::CompositeT</a>&lt; M &gt;::add </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add new rule to rule sequence by passing the type of the wanted rule as template argument to the method. </p>
<dl class="section return"><dt>Returns</dt><dd>Valid handle on success. Else it is invalid. </dd></dl>

</div>
</div>
<a id="a748163a4a7c7f45f7714ae5ff724d014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a748163a4a7c7f45f7714ae5ff724d014">&#9670;&nbsp;</a></span>add() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<div class="memtemplate">
template&lt;typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02857.html">RuleHandleT</a>&lt;R&gt;&amp; <a class="el" href="a02865.html">OpenMesh::Subdivider::Adaptive::CompositeT</a>&lt; M &gt;::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a02857.html">RuleHandleT</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>_rh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add new rule to rule sequence by passing an appropriate handle to the method. </p>
<dl class="section return"><dt>Returns</dt><dd>Valid handle on success. Else it is invalid. </dd></dl>

</div>
</div>
<a id="ad80960eb4a617e8bd46fdebdf842c4f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad80960eb4a617e8bd46fdebdf842c4f1">&#9670;&nbsp;</a></span>cleanup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a02865.html">OpenMesh::Subdivider::Adaptive::CompositeT</a>&lt; M &gt;::cleanup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset <code>self</code> to state after the default constructor except of the mesh. </p>

</div>
</div>
<a id="a99ff9d4f4a55f612ee10dd1c5d0aa60d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99ff9d4f4a55f612ee10dd1c5d0aa60d">&#9670;&nbsp;</a></span>rule() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<div class="memtemplate">
template&lt;typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02857.html">RuleHandleT</a>&lt;R&gt;::<a class="el" href="a02861.html">Rule</a>&amp; <a class="el" href="a02865.html">OpenMesh::Subdivider::Adaptive::CompositeT</a>&lt; M &gt;::rule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a02857.html">RuleHandleT</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>_rh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get rule in the rule sequence by a handle. </p>
<dl class="section return"><dt>Returns</dt><dd>The wanted rule if the handle is valid. The return value is undefined if the handle is invalid! </dd></dl>

</div>
</div>
<a id="a8df1c3098721d47a64c64f9bbafe5639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8df1c3098721d47a64c64f9bbafe5639">&#9670;&nbsp;</a></span>rule() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02861.html">RuleInterfaceT</a>&lt;M&gt;&amp; <a class="el" href="a02865.html">OpenMesh::Subdivider::Adaptive::CompositeT</a>&lt; M &gt;::rule </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get rule (interface) by index. </p>
<dl class="section return"><dt>Returns</dt><dd>The wanted rule if the handle is valid. The return value is undefined if the handle is invalid! </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>OpenMesh/Tools/Subdivider/Adaptive/Composite/<a class="el" href="a04491_source.html">CompositeT.hh</a></li>
<li>OpenMesh/Tools/Subdivider/Adaptive/Composite/<a class="el" href="a04497_source.html">CompositeT_impl.hh</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr>
<address>
<small>
<a href="http://www.rwth-graphics.de" style="text-decoration:none;">
</a>
Project <b>OpenMesh</b>, 
&copy;&nbsp; Computer Graphics Group, RWTH Aachen.
Documentation generated using 
<a class="el" href="http://www.doxygen.org/index.html">
<b>doxygen</b>
</a>.
</small>
</address>
</body>
</html>
